* Reduce是最核心和基础的功能，map, filter等等都可以用reduce来完成
* Reduce使用一个reducing function(rf)做做具体每一步的处理
** #+BEGIN_SRC clojure
;; reducing function signature
;; whatever, input -> whatever

(defn rf
  ([] initial-value)
  ([accum] (finalize accum))
  ([accum elem] (combine accum elem)))

#+END_SRC
** 一个例子
#+BEGIN_SRC clojure
(defn rf
  ([] (transient []))
  ([v] (persistent! v))
  ([v x] (conj! v x)))

(defn map-core
  [f]
  (fn [rf]
    (fn [accumulator element]
      (rf accumulator (f element)))))

(defn -map
  ([f coll]
   (-map f (rf) coll))
  ([f acc coll]
   (rf (-reduce ((map-core f) rf) acc coll))))

(-map inc [1 2 3 4 5 6 7 8])
#+END_SRC
* What is a transducer? #card #clojure
:PROPERTIES:
:card-last-interval: 8.34
:card-repeats: 1
:card-ease-factor: 2.6
:card-next-schedule: 2022-05-04T08:58:36.535Z
:card-last-reviewed: 2022-04-26T00:58:36.537Z
:card-last-score: 5
:END:
** A transducer (sometimes referred to as xform or xf) is a transformation from one reducing function to another
** #+BEGIN_SRC clojure
;; reducing function signature
;; whatever, input -> whatever

;; transducer signature
;; (whatever, input -> whatever) -> (whatever, input -> whatever)

(transduce xform rf init coll)
;; xform is transducer which transform rf(which is a reducing function) to another rf', 
;; then transduce call reduces coll with rf'
#+END_SRC
* Transduce操作的三个重要组成部分都是哪些？ #card #clojure
:PROPERTIES:
:card-last-interval: 8.34
:card-repeats: 1
:card-ease-factor: 2.6
:card-next-schedule: 2022-05-04T09:00:02.670Z
:card-last-reviewed: 2022-04-26T01:00:02.671Z
:card-last-score: 5
:END:
** iteration -- 这个是由reduce API(由reducible thing实现)来负责
** accumulation -- 这个是由最初的reducing function来负责
** transform/processing -- 这个是由transducer来负责
** 这三个部分是互相正交的
* eduction的功能是什么？ #card #clojure
:PROPERTIES:
:card-last-interval: 8.34
:card-repeats: 1
:card-ease-factor: 2.6
:card-next-schedule: 2022-05-04T09:00:36.749Z
:card-last-reviewed: 2022-04-26T01:00:36.749Z
:card-last-score: 5
:END:
** #+BEGIN_SRC clojure
(eduction xform* coll)
;; eduction创建了一个xform应用在coll上面的promise，当后面的reduce发生的时候，会实际执行xform

(def iter (eduction xf (range 5)))
(reduce + 0 iter)
;; => 6
#+END_SRC
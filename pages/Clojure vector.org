* 创建一个vector的函数有哪些？ #card #clojure
:PROPERTIES:
:card-last-interval: 11.2
:card-repeats: 3
:card-ease-factor: 2.8
:card-next-schedule: 2022-04-21T05:02:55.924Z
:card-last-reviewed: 2022-04-10T01:02:55.924Z
:card-last-score: 5
:END:
** #+BEGIN_SRC clojure
;从一个collection创建vector，类似于转换成vector
(vec (range 10))
;=> [0 1 2 3 4 5 6 7 8 9]

; 已经有了vector，但想加入些值进去
(into [:a :b :c] (range 10))
;=> [:a :b :c 0 1 2 3 4 5 6 7 8 9]

; 从参数字面量创建一个vector
(vector 1 2 3)
;=> [1 2 3]
#+END_SRC
* 获取vector元素的值有哪些方法？ #card #clojure
:PROPERTIES:
:card-last-interval: 11.2
:card-repeats: 3
:card-ease-factor: 2.8
:card-next-schedule: 2022-04-21T05:01:06.294Z
:card-last-reviewed: 2022-04-10T01:01:06.294Z
:card-last-score: 5
:END:
** |  | nth | get | vector当作函数 |
| 语法 | (nth my-vec 1) | (get my-vec 1) | (my-vec 1) |
| my-vec 为 nil | nil | nil | 异常 |
| 索引越界 | not found异常 | nil | 异常 |
| 未找到缺省值 | (nth [] 9 :whoops) | (get [] 9 :whoops) | 不支持 |
* 修改vector元素值的方法通常有哪些？ #card #clojure
:PROPERTIES:
:card-last-interval: 4
:card-repeats: 2
:card-ease-factor: 2.7
:card-next-schedule: 2022-04-10T01:10:44.928Z
:card-last-reviewed: 2022-04-06T01:10:44.929Z
:card-last-score: 5
:END:
** #+BEGIN_SRC clojure
(assoc [1 2 3] 1 9)
;=> [1 9 3]

(update [1 2 3] 1 + 5)
;=> [1 7 3]

(conj [1 2 3] 4 5 6)
;=> [1 2 3 4 5 6]
#+END_SRC
* 将vector用作栈stack的相关函数有哪些？ #card #clojure
:PROPERTIES:
:card-last-interval: 11.2
:card-repeats: 3
:card-ease-factor: 2.8
:card-next-schedule: 2022-04-21T04:57:11.752Z
:card-last-reviewed: 2022-04-10T00:57:11.753Z
:card-last-score: 5
:END:
** #+BEGIN_SRC clojure
(def my-stack [1 2 3])

(peek my-stack)
;=> 3

(pop my-stack)  ;注意，pop返回的是去掉最上面(最右面)元素之后的vector，而不是被去掉的元素
;=> [1 2]

(conj my-stack 4)
;=> [1 2 3 4]

(+ (peek my-stack) (peek (pop my-stack)))
;=> 5
#+END_SRC
* 如何查找某个元素是否在vector中？ #card #clojure
:PROPERTIES:
:card-last-interval: 10.24
:card-repeats: 3
:card-ease-factor: 2.56
:card-next-schedule: 2022-04-20T06:01:44.580Z
:card-last-reviewed: 2022-04-10T01:01:44.618Z
:card-last-score: 5
:END:
** 使用some而不是contains?，因为contains?查找的是*键*(对于vector，键就是index)是否存在而不是值
** #+BEGIN_SRC clojure
; some returns the first element that returns true from the function
(some #{3} [1 2 3 4 5]) ; => 3
(some #(= 3 %) [1 2 3 4 5]) ; => 3
(some #(= :nope %) [1 2 3 4 5]) ; => nil

; contains returns true if an element exists at that index in the vector
(contains? [1 1 1 1 1] 3) ; => true
(contains? [5 5 5 5] 5) ; => false
(contains? [nil nil nil] 1) ;=> true
#+END_SRC
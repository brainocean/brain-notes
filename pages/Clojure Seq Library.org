* 访问seq里面的某个元素有哪些函数？ #card #clojure
:PROPERTIES:
:card-last-interval: 3.33
:card-repeats: 1
:card-ease-factor: 2.36
:card-next-schedule: 2022-04-30T08:09:48.327Z
:card-last-reviewed: 2022-04-27T01:09:48.329Z
:card-last-score: 3
:END:
** | 函数 | 功能 |
| (first coll) | 第1个 |
| (second coll) | 第2个 |
| (ffirst coll) | (first (first coll)) |
| (last coll) | 最后一个 |
| (nth coll n not-found) | 第n个 |
| (rand-nth coll) | 随机选择一个元素 |
| (peek coll) | queue的第一个，vector的最后一个元素 |
* 选择seq的一部分元素有哪些函数？ #card #clojure
:PROPERTIES:
:card-last-interval: 8.34
:card-repeats: 1
:card-ease-factor: 2.6
:card-next-schedule: 2022-05-05T09:10:37.734Z
:card-last-reviewed: 2022-04-27T01:10:37.734Z
:card-last-score: 5
:END:
** | 函数 | 功能 |
| (filter pred coll) | 过滤出(pred item)为true的元素 |
| (keep f coll) | 保留(f item)为non-nil的元素 |
| (keep-indexed f coll) | 保留(f index item)为non-nil的元素 |
| (remove pred coll) | 删除(pred item)为true的元素 |
| (distinct coll) | 去掉*所有*重复元素 |
| (dedupe coll) | 去掉*连续*重复的元素 |
| (take n coll) | 取前n个元素 |
| (take-nth n coll) | 每n个元素取一个 |
| (take-last n coll) | 取后n个元素 |
| (take-while pred coll) | 从头依次取元素直到(pred item)为false，舍弃后面的元素 |
| (drop n coll) | 去掉前n个元素 |
| (drop-last n coll) | 去掉后n个元素 |
| (drop-while pred coll) | 从头依次去掉元素直到(pred item)是false，保持后面的元素 |
| (butlast coll) | 去掉最后一个元素 |
* 合并多个seq的函数有哪些？ #card #clojure
:PROPERTIES:
:card-last-interval: 3.33
:card-repeats: 1
:card-ease-factor: 2.36
:card-next-schedule: 2022-05-01T08:17:46.965Z
:card-last-reviewed: 2022-04-28T01:17:46.966Z
:card-last-score: 3
:END:
** | 函数 | 功能 |
| (concat x y & zs) | 依顺序连接 |
| (mapcat f & colls) | 先对colls中的每个coll执行(map f)，然后concat结果 |
| (interleave c1 c2 & colls) | 逐个取每个coll中的元素，拼接成一个seq |
| (flatten x) | 把所有嵌套的sequence展平形成一个flat lazy seq |
* 处理seq的每个元素的函数有哪些？ #card #clojure
** | 函数 | 功能 |
| (map f c1 c2 c3 & colls) | 把f应用到c1, c2, c3...的各个元素上，结果形成一个seq |
| (map-indexed f coll) | 把(f index item)的结果形成新的seq |
| (replace smap coll) | coll中的元素如果等于smap中的某个key，则它的值被对应的val取代 |
| (reductions f init coll) | 对每个sub-coll = (take n coll), n从0到(count coll)，计算(reduce f init sub-coll)，结果形成一个seq |
* 改变seq元素顺序的函数有哪些？ #card #clojure
** | 函数 | 功能 |
| (sort comp coll) | 按照comp item的值排序coll元素 |
| (sort-by keyfn comp coll) | 按comp (keyfn item)的结果排序 |
| (reverse coll) | 反序 coll，注意结果不是lazy的 |
| (shuffle coll) | 乱序coll |
* 分割seq的函数有哪些？ #card #clojure
** | 函数 | 功能 |
| (split-at n coll) | 返回vector [(take n coll) (drop n coll)] |
| (split-with pred coll) | 返回vector [(take-while pred coll) (drop-while pred coll)] |
| (partition n step pad coll) | 把coll分成多个子seq，每step个元素开始分割，每个子seq取n个元素，不足的用pad中的元素补足，如果没提供pad，不足n个的最后一个子seq会被丢弃 |
| (partition-all n step coll) | 分割成多个子seq，最后一个子seq元素数量可能不足n |
| (partition-by f coll) | 按照(f item)的返回值对coll进行分组 |
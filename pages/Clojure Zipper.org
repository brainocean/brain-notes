* 什么是Zipper? #card #clojure
:PROPERTIES:
:card-last-interval: -1
:card-repeats: 1
:card-ease-factor: 2.5
:card-next-schedule: 2022-08-22T16:00:00.000Z
:card-last-reviewed: 2022-08-22T00:41:00.774Z
:card-last-score: 1
:END:
** zipper = tree + path
*** some kind of tree-shaped data structure
*** a pointer to a node within the tree
* Zipper有什么用？ #card #clojure
:PROPERTIES:
:card-last-interval: 0.84
:card-repeats: 1
:card-ease-factor: 2.6
:card-next-schedule: 2022-08-22T20:41:30.044Z
:card-last-reviewed: 2022-08-22T00:41:30.045Z
:card-last-score: 5
:END:
** Move around in the tree
** Modify the tree at your current location
* Zipper tree的表现形式？ #card #clojure
:PROPERTIES:
:card-last-interval: -1
:card-repeats: 1
:card-ease-factor: 2.5
:card-next-schedule: 2022-08-22T16:00:00.000Z
:card-last-reviewed: 2022-08-22T00:39:15.251Z
:card-last-score: 1
:END:
** 嵌套vector (z/vector-zip v)
** 嵌套sequence (z/seq-zip s)
** XML文档 (z/xml-zip doc)
** Anything that has nodes and child nodes  (z/zipper ... root)
* 在Zipper中访问节点的函数有哪些？ #card #clojure
:PROPERTIES:
:card-last-interval: 0.84
:card-repeats: 1
:card-ease-factor: 2.6
:card-next-schedule: 2022-08-22T20:39:46.490Z
:card-last-reviewed: 2022-08-22T00:39:46.490Z
:card-last-score: 5
:END:
** root, node, children, lefts, rights, branch?, path
* 在Zipper中在树中移动的函数有哪些？ #card #clojure
:PROPERTIES:
:card-last-interval: 0.84
:card-repeats: 1
:card-ease-factor: 2.6
:card-next-schedule: 2022-08-22T20:39:58.575Z
:card-last-reviewed: 2022-08-22T00:39:58.576Z
:card-last-score: 5
:END:
** down, up, left, right, leftmost, rightmost, root
* 在Zipper中修改当前节点的函数有哪些？ #card #clojure
:PROPERTIES:
:card-last-interval: 0.84
:card-repeats: 1
:card-ease-factor: 2.6
:card-next-schedule: 2022-08-22T20:40:27.849Z
:card-last-reviewed: 2022-08-22T00:40:27.849Z
:card-last-score: 5
:END:
** #+BEGIN_SRC clojure
(replace loc "new value")  
(edit loc assoc-in [:attrs :price] 2.9)  
(remove loc) ;; 注意删除节点之后，回到深度优先遍历序的前一个节点位置  
#+END_SRC
* 在Zipper中添加节点的函数有哪些？ #card #clojure
:PROPERTIES:
:card-last-interval: 0.84
:card-repeats: 1
:card-ease-factor: 2.6
:card-next-schedule: 2022-08-22T20:40:49.195Z
:card-last-reviewed: 2022-08-22T00:40:49.196Z
:card-last-score: 5
:END:
** #+BEGIN_SRC clojure
insert-left, insert-right  
append-child ;;rightmost
insert-child ;;leftmost
#+END_SRC
* 在Zipper中如何深度优先遍历一棵树？ #card #clojure
:PROPERTIES:
:card-last-interval: 0.84
:card-repeats: 1
:card-ease-factor: 2.6
:card-next-schedule: 2022-08-22T20:41:22.368Z
:card-last-reviewed: 2022-08-22T00:41:22.368Z
:card-last-score: 5
:END:
** #+BEGIN_SRC clojure
;; prev, next, end?  

(def vz (z/vector-zip [[1 2] [3 [4 5] 6]]))
(iterate z/next zipper)  
(z/end? (nth (iterate z/next vz) 9))
;=> false
(z/end? (nth (iterate z/next vz) 10))
;=> true

;; 注意，当遇到:end之后，调用prev不起作用，返回nil
#+END_SRC
* 请参考这个slides: [[https://arnebrasseur.net/talks/2018-clojure-zip-denver/][The Art of Tree Shaping with Zippers]]